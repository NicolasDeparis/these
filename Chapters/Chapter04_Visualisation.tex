\section{Introduction a la visualisation de données}

 
Nous revenons au concept Observation -> théorie -> expérience.
La visualisation représente l'étape d'observation du cycle.

La visualisation de donnée scientifique est importante car elle permet d'obtenir énormément d'information.

%pour qui?
Avant même de définir un but il faut definir une cible.
Les outils ne seront pas les mêmes en fonction de la cible a laquelle ils s'adressent


\begin{itemize}
\item Les scientifiques.
Aligner des 1 et des 0 sur des gros ordinateur, n'a vraiment de sens que si il représente quelque chose.
Le mot important dans cette phrase est représentation.
Il est nécessaire, en recherche de visualiser ce qui se passe dans les simulations pour comprendre et qualifier les phénomènes avant de pouvoir les quantifier.
Cette cible aura besoin d'outils pointu aillant pour principal objectif la quantification.

\item L'éducation 
Ratio équitable entre qualification et quantification

\item Le grand public./ La vulgarisation
Qualification principalement 
il est important de creer des belles image
\end{itemize}

Mais la visualisation est un défis car les volumes de données sont généralement important.


%Pourquoi

Le monde de la 3D.
Les simus, les moteurs de jeux video, les SFX de films,
La 3D est partout.
Les monde des simulation peux s'en inspirer.


\section{Projeter une grille AMR}

\subsection{Le concept de ligne de visées}

D'une manière générale, les simulations cosmologiques utilisent un espace en 3 dimensions.

La représentation d'un environnement virtuel a 3 dimensions passe toujours par la création d'une image a deux dimensions.
Pour faire cette transformation, qui nécessité de supprimer une dimension, il est nécessaire d'établir le concept de ligne de visée.

Il existe différents types de méthode de projections.
Dans la suite de ce chapitre nous allons développer deux d'entre elles: la projection en perspective et la projection orthogonal (Fig \ref{fig:raycast_projection}).

La projection en perspective correspond au cas l'observateur est ponctuel et au centre d'une sphere, les rayons lumineux lui arrive radialement.
C'est la projection qui se rapproche le plus de la vision "naturelle".

La projection orthogonale correspond a l'approximation de grande distance.
Les rayon sont parralèles entre eux et l'image recue est comme "imprimée".
Cette projection est moins naturelle dans le sens ou elle ne correspond pas a ce que nous pouvons percevoir, mais elle a l'avantage d'être tres simple a mettre en oeuvre.



\begin{figure}[bth]
        \includegraphics[width=.95\linewidth]{img/04/raycast_projection.png} 
        \caption{Deux types de projections}
 		\label{fig:raycast_projection}
\end{figure}


\subsection{la réduction de la ligne de visée}

Dans les cas l'objectif est de réduire une ligne de visée a une valeurs a représenter a l’écran.
Il existe plusieurs façons de réduire les lignes de visées.

Une des méthodes les plus facile consiste a prendre la moyenne ou la somme de la ligne, cette méthode présente l'avantage de représenter l'ensemble de la ligne.
Il est également possible de prendre les maximum de la ligne, cette méthode augmente significativement le contraste, au point que certaines projections peuvent présenter des artefacts indésirables.

Une troisième méthodes légèrement plus physique consiste a utiliser les équations de transfert du rayonnment pour determiner l'epaisseur optique de la ligne

\begin{equation}
v= \sum e^{-d}
\end{equation}

Enfin, il est possible d'utilisé la réelle expression de l'epaisseur optique, prenant en compte densité, température, ionization et vitesse du gaz.
(TODO)


\subsection{Projection orthogonale}
J'ai développer une méthode de projection d'AMR utilisant les fonction histogramme de numpy.
Ces fonctions étant très optimisées, la performance de génération de cube est généralement satisfaisante (quelque secondes pour un cube de niveau 10).
L'idée est de considéré les cellule AMR comme des particules d'une certaine taille.

Prenon l'exemple d'une grille de densité non raffiné utilisant les sorties EMMA.
Une grille 2d  quelconque est représenté par x,y,l et d ou x,y etant les position du bord inferieur guauche des cellules, l étant le niveau des cellules d etant le champs a représenter (ici la densité).

\begin{equation}
dV= \left( \frac{1}{2**L }\right) **3
\end{equation} 

En réalisant un histogram 2d de x et y pondéré en masse.
Le poids de chaque cellule correspond a la masse de la cellule $w = \rho \cdot dV$:
En considerant le centre des cellule $(x' = x+dx(L) /2)$ et en ajustant le bin de l'histograme sur la taille de la grille on peux projeter un niveau tres rapidement.

\begin{lstlisting}[float=bth,language=python,frame=tb,caption={lprojection de l'AMR par la méthode des histogramme Numpy},label=lst:useless]
 import numpy as np
 h,binX,binY=np.hystogram2d(x,y,weight=dv)
\end{lstlisting}

ou h est une matrice 2d representant la projection.


Lorsque l'AMR d'entrée contient plusieurs niveaux, il est possible de projeter les cellules niveau par niveau.
Par example pour une grille contenant les niveaux 8 et 9, on projettera d'abord toutes les cellules de niveau 8 pour obtenir une matrice 256x256.
puis on agrandira cette matrice avec des operateurs de changement de grille (TODO cf multigrille).
La méthode la plus naturelle consiste utiliser une projection directe.
nous obtenons alors une premiere grille de taille 512x512.
On projettera ensuite par histogramme toutes les cellules du niveau  9 pour obtenir une seconde matrice de taille 512x512.
La grille finale sera la moyenne des deux grille précédentes.

On pourra utiliser ce principe de manière récursive jusqu'a avoir projeter tout les niveaux.

Dans le cas ou le niveau de projection ne correspond pas au niveau maximum de l'AMR, il suffira de modifier la pondération des niveau superieur au niveau de projection en utilisant:

\begin{equation}
w = d \cdot \left( \frac{1}{2**(L-Lmax) }\right) **3
\end{equation}



L'inconveniant de la methode des histogramme est qu'il n'est possible de realiser que des projection utilisant la moyenne.
Or on voudra dans certain cas considérer d'autres reduction de ligne de visée.
Pour compenser cette methode on realisera une projection 3d de la même maniere que precedement mais en utilisant numpy.hystogramdd qui permet de realiser des histogrammes a N dimensions.
La taille de l'histogramme augmentant en 2**3L les projections 3d seront genéralement limité a 1024**3 pour des question de mémoire RAM. 





%matplotlib
%PIL
openseadragon
%








\section{Projection perspective}
%opengl
%blender

Dans ce cas, il n'existe plus de façon directe de recuperer les lignes de visée, il est nécessaire d'avoir recours au lancé de rayon.
Cette technique appelée raycasting permet de récupérer toute les cellules interceptée pas un rayon donné.
Il existe différentes techniques de raycasting, j'ai pu en explorer plusieurs:

\subsection{L'algorithme de bressenham}
L'algorithme de bressenham est une technique optimisée de raycasting.
Il consiste a travailler sur l'indice des cellules d'une grille regulière.

Cette technique est tres rapide mais ne fonctionne cependant que sur grille regulière.

\begin{figure}[bth]
        \includegraphics[width=.95\linewidth]{img/04/Bresenham_line.png} 
        \caption{Algorithme de Bressenham }
 		\label{fig:bressenham}
\end{figure}




\subsection{La méthodes KD-tree}

Une autre technique mise en place dans le but d'explorer directement l'amr.
De la mème manière que la technique de calcule des flux (TODO ref) cette technique repose sur l'utilisation d'un arbre pour determiner le cellule par lesquelles passent le rayon.





la mise en place de la camera
la définition de la position et du champs de vue (FOV) et de la profondeur de vue.
camera sphérique avec HealPix see Sec. \ref{sec:healpix}

la projection equirectangle est la projection la plus utilisée en photographie et video sphérique.
Elle présente un ratio d'aspect de 2:1 correspondant a 360:180.
L'association Healpix vers equirectangle est trivial puisque qu'elle consiste a associer les position x,y de la projection equirectangle, au angle $\theta$ et $\phi$ de la projection Healpix.
\begin{equation}
x=\theta
y=\phi
\end{equation}

La densité de point n'etant pas uniforme dans ce reférentiel, il est necessaire de realiser une interpolation sur une matrice régulière pour obtenir l'image finale. see Fig \ref{fig:equirectangle}


\begin{figure}[bth]
        \includegraphics[height=.95\textheight]{img/04/equi.png} 
        \caption{Projection equirectangle d'une cube de densité}
 		\label{fig:equirectangle}
\end{figure}

Ce type d'image se prettent bien a la vulgarisation, car le resultat final est légé et peut être utilisé avec un Google Cardboard par exemple pour obtenir une visualisation intéractive facilement rependable.

\section{le compositing RGB (A)}
Une fois les projections realisées il est possibles de les combiner en créant des images en fausses couleurs.

De maniere naturelle, J'ai utilisé le rouge pour  la température et la transparence pour l'ionization.
il reste le bleu et le vert.
Dans une première série d'images j'ai utilisé le vert pour la densité de gas et le bleu pour la densité de matière noire.

\subsection{le théorie des couleurs}
Comment créer du noir et blanc?


par la moyenne :
\begin{equation}
gray= (R+G+B)/3
\end{equation}

R,G,B=gray


par une ponderation spéciale correspondant a la capacité de l'oeil a voir certaine couleur, conservation de la luminance:
\begin{equation}
gray = R*0.2989 + G*0.5870 +B*0.1140
\end{equation}

R,G,B=gray


\section{Movie}
%implementation du mode movie de EMMA
%c'est la même chose que précedemment mais a chaque pas de temps, il faut l'implementer en live (en c) pour ne pas avoir a sortir toute les info.


J'ai implémenté dans EMMA, la possibilité d'obtenir une matrice 2D par pas de temps, représentant la projection orthogonale suivant un axe donné.
La projection est réalisée de la même manière que précédemment mais a la volée et a chaque pas de temps.
Le choix a été fait de réaliser la projection a la fin de chaque pas de temps coarse.
La résolution temporelle est donc la résolution temporelle du pas de temps coarse.
Comme la résolution temporelle des niveaux raffinés est plus importante que le niveau coarse, 
LA projection temporelle peux etre 
En écrivant ces lignes je me rends compte que le dt de projection devrait être lié au dx de projection. 

Les simulations que j'ai pu réalisées comportaient environs un millier de pas temps, et généraient donc autant d'images ($N_{dt} \approx 10^3$).
A 25 FPS cela représente une durée de 40 secondes de vidéo.




\section{Light cone}
La création d'un light cone se fait a partir des images générer par le mode movie.
Le cube est 

Si les images en sorties du mode movie on une résolution $N_p=1024$ pixel carré.
On prend une tranche d'une épaisseur $dx$ donnée suivant l'axe $y$ sur l'image du pas de temps $i_{dt}$, puis une deuxième tranche de la même épaisseur, mais décalée dans l 'image $i_{dt+1}$, et ainsi de suite.

La position du début $S_i$ et de la fin $S_f$ de la tranche dans l'image sera :

\begin{equation}
S_i = (dx * i_{dt}) \% N_p 
\end{equation} 
\begin{equation}
S_f = S_i + dx 
\end{equation} 

Le modulo sur la taille de l'image permet de gérer les conditions périodiques simplement.
On prendra également garde a utiliser une épaisseur de tranche qui soit un multiple entier du nombre de pixel de l'image de manière a respécter simplement les condition périodique

Le ratio d'aspect $\Phi$ est le rapport entre la hauteur et la longueur de l'image, et s'exprime :
\begin{equation}
\Phi = \frac{ N_{dt} * dx}{N_p}
\end{equation}
Étant donné que $N_{dt}$ et $N_p$ sont fixés par les paramètres de la simulation, il n'est possible de géré le ratio d'aspect qu'en fonction de l'épaisseur de la tranche $dx$, 

Plus le ratio d'aspect sera important, plus les structure vont se répétée sur le light cone.

Un light cone réaliser avec cette méthode et a partir d'une simulation présenté dans la partie %TODO ref
est présenté sur la figure \ref{fig:lightcone}


\begin{figure}[bth]
        \includegraphics[height=.95\textheight]{img/04/frise_wall.png} 
        \caption{Light cone dans une simulation $8/h Mpc ^3$. Le temps se déroule de haute en bas sur plus de 700 Myrs }
 		\label{fig:lightcone}
\end{figure}

\section{Projeter des particules en 3D}

\subsection{avec un frame work} 
Irlicht

Blender 



\subsection{Sans Framework}

J'ai develloper un visualisateur de aprticule en OPenGL

OpenGL
intéraction avec CUDA


